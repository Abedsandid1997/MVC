{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
<div class="me">
    <div class="redovisning">
     <h1><a href="{{ path("kmom01") }}">kmom01</a></h1>
    <p>
    Under det här kursmomentet stötte jag på utmaningar på grund av den överflöd av ny information,
    inklusive Symfony, OOPHP och arbete med routes i PHP och JSON API.
    Trots dessa utmaningar fann jag det också vara en berikande och spännande erfarenhet.
    Koncepten med klasser och routes var inte så svåra att förstå,
    då de delvis liknade de jag tidigare stött på i Python och JavaScript.
    Skillnaderna låg främst i strukturen och syntaxen.
    Symfony var en ny plattform för mig och att få en djupare förståelse för dess
    kodstruktur och användning av olika paket var en fascinerande del av kursen.
    Genom att utforska Symfony och dess komponenter fick jag också
    möjlighet att fördjupa min kunskap om PHP-klasser och effektiv hantering av routes.
    Sammanfattningsvis var detta kursmoment en betydelsefull del av min resa inom webbutveckling,
    och jag känner mig mer säker och kunnig när det gäller att arbeta med PHP och Symfony.
    </p>
    </div>

    <div class="redovisning">
     <h1><a href="{{ path("kmom02") }}">kmom02</a></h1>
    <p>Under detta kursmoment fick jag en djupare förståelse för klasser i PHP,
    inklusive koncept som arv och komposition.
    Jag lärde mig hur man ärver egenskaper från en befintlig klass och hur man använder en klass inuti en annan klass,
    samt om de relationer som uppstår mellan dem.
    Dessutom fick jag insikt i hanteringen av sessioner och minnet i routes genom sessionssnittgränssnittet.
    Att använda post-formulär i routes var också en del av kursen.
    Även om jag tidigare hade erfarenhet av detta från tidigare kurser i JavaScript och Python,
    var det nytt för mig att arbeta med postning till ett JSON-API.
    I början var det utmanande att förstå hur jag skulle hantera detta,
    men tack vare övningarna kom jag på att använda ett formulär som postar till JSON-routen.
    Det var både roligt och utmanande, men jag kände att jag fick mycket värdefull information från detta kursmoment.
    Genom att tillämpa koncepten och övningarna i
    praktiken fick jag en mer robust förståelse för hur man skapar och hanterar klasser i PHP-miljön.
    Det öppnade också upp nya möjligheter för mig att utveckla webbapplikationer
    med PHP och integrera dem med andra tekniker som JSON-API:er.
    Sammantaget var kursmomentet en berikande erfarenhet som fördjupade mina kunskaper
    och gav mig verktyg för att ta min webbutveckling till nästa nivå.</p>
    </div>

    <div class="redovisning">
     <h1><a href="{{ path("kmom03") }}">kmom03</a></h1>
    <p>Modelleringen av ett kortspel med flödesdiagram och pseudokod var en givande erfarenhet. Det hjälpte mig att visualisera hur spelet skulle fungera steg för steg och identifiera viktiga beslutspunkter i spelets logik. Att skapa pseudokod gjorde det också lättare att planera och organisera koden innan jag började implementeringen.

När det gäller min implementation av uppgiften, löste jag den genom att först skapa klasser för spelaren, banken och spelet självt.
Att skriva koden för klasser var inte så svårt i Princep. Det som var utmanande var att komma på idéer och bestämma vilka attribut och metoder som skulle ingå. Men det var något vi redan hade övat på under förra kursmomentet.

Jag är nöjd med den grundläggande funktionaliteten, men jag ser också förbättringspotential i min kodstruktur och klassdesign. Till exempel skulle jag kunna refaktorisera vissa delar för att göra koden mer läsbar och modulär.

Att koda i Symfony har varit en lärorik upplevelse. Ramverket erbjuder många praktiska verktyg och konventioner som underlättar utvecklingen av komplexa webbapplikationer. Jag uppskattar särskilt den inbyggda routningen och konfigurationshanteringen, vilket sparar tid och minskar risken för fel.

Min TIL för detta kursmoment är vikten av att använda pseudokod och flödesdiagram för att planera och strukturera kod innan man börjar implementera den. Det hjälper till att undvika förvirring och ökar förståelsen för problemet och dess lösning.</p>
    </div>

    <div class="redovisning">
     <h1><a href="{{ path("kmom04") }}">kmom04</a></h1>
    <p>
    Att skriva testkod med PHPUnit har varit en lärorik och givande upplevelse.
    PHPUnit är ett kraftfullt verktyg som gör det möjligt att skapa robusta och omfattande enhetstester.
    Jag uppskattar dess struktur och hur det uppmuntrar en modulär och återanvändbar kodbas.

    Jag lyckades uppnå 100% kodtäckning för alla mina modellklasser i kortspelet.
    Detta innebär att varje funktion i koden har testats och verifierats för att fungera som förväntat.
    Att nå denna nivå av täckning har gett mig större förtroende för kodens stabilitet och tillförlitlighet.

    Det fanns dock vissa utmaningar, särskilt när det gällde att testa Game-klassen.
    Game-klassen är sammansatt av två andra klasser, Player och Bank, som i sin tur använder DeckOfCards-klassen.
    Denna komplexa sammansättning gjorde det lite svårare att isolera och testa Game-klassen.
    Trots dessa utmaningar kunde jag skapa effektiva tester för alla delar av min kod
    utan att behöva ändra den för att göra den mer testbar.

    Jag upplever att min egen kod är ganska testbar.
    Det finns vissa delar som var mer utmanande att testa,
    men med hjälp av mock-objekt och stubbar kunde jag ändå täcka dessa delar effektivt.
    Jag behövde inte skriva om någon del av min kod för att kunna testa den,
    vilket indikerar att den ursprungliga designen var tillräckligt modulär och flexibel för att stödja enhetstester.

    Jag anser att testbar kod ofta sammanfaller med "snygg och ren kod".
    Testbar kod är vanligtvis välstrukturerad, har tydliga gränssnitt och är fri från onödig komplexitet,
    vilket också är kännetecken för ren kod.
    Genom att sträva efter att skriva testbar kod förbättras kodens övergripande kvalitet och underhållbarhet.
    I detta kursmoment lärde jag mig om enhetstester i PHP och hur kodens struktur påverkar
    möjligheten att skriva meningsfulla tester.
    Jag insåg att en välstrukturerad kod gör det mycket enklare att skapa omfattande tester.
    Jag lärde mig också om DocBlock och hur man skriver kommentarer för att göra koden mer läsbar
    och begriplig genom att tydligt förklara alla metoder och attribut.
    Jag valde att skriva DocBlock-kommentarer för Game-klassen.
    </p>
    </div>

    <div class="redovisning">
     <h1><a href="{{ path("kmom05") }}">kmom05</a></h1>
    <p>
    Att arbeta med Symfony och Doctrine i denna övning gick överlag bra.
    Processen var smidig tack vare den välstrukturerade dokumentationen och de inbyggda verktygen som Symfony erbjuder.
    Ett särskilt inslag som förenklade arbetet var möjligheten att snabbt generera entiteter och
    hantera databasmigrationer med Doctrine. Jag uppskattade verkligen hur Symfony och Doctrine integrerar med varandra,
    vilket underlättar att hålla koden ren och fokusera på affärslogiken snarare än detaljerade SQL-frågor.

    Min applikation är en enkel bokhanteringsapplikation där användare kan skapa,
    redigera, visa och radera böcker. När jag byggde upp applikationen tänkte jag mycket på att följa goda designprinciper,
    såsom att hålla koden modulär och enkel att underhålla.

    Att arbeta med ORM för att implementera CRUD-funktionalitet gick mycket bra.
    Doctrine erbjuder ett kraftfullt och flexibelt sätt att hantera databaser utan att behöva skriva mycket SQL-kod.
    Jämfört med att direkt använda SQL, där man måste hantera mycket mer av de lågnivå detaljerna själv, var detta en stor fördel.
    Med Doctrine kunde jag definiera mina databasmodeller som PHP-klasser och låta ORM:en hantera databaskommunikationen,
    vilket resulterade i mer läsbar och underhållbar kod.

    En annan fördel med att använda ORM var att det var lätt att göra komplexa databasoperationer,
    som att definiera relationer mellan entiteter, utan att skriva omfattande SQL-frågor.

    Sammanfattningsvis tycker jag att ORM är ett utmärkt verktyg för de flesta applikationer,
    särskilt när man vill fokusera på affärslogik och snabb utveckling.
    Det kan dock vara bra att ha en förståelse för underliggande SQL och vara beredd
    att gå utanför ORM:en vid behov för att hantera specifika prestandakrav.
    Min uppfattning om ORM är övervägande positiv, och jag ser fram emot att använda Doctrine i framtida projekt
    för att dra nytta av dess kraftfulla och flexibla funktioner.

    Under detta kursmoment (kmom) lärde jag mig hur kraftfull och användbar Symfony och
    Doctrine kan vara när det gäller att snabbt och effektivt bygga webbapplikationer med komplexa databashanteringskrav.
    En viktig lärdom var hur man korrekt hanterar typer och säkerställer
    att data från användarinmatning är i rätt format innan de skickas vidare till entitetsmetoder,
    vilket är avgörande för att undvika typfel och potentiella buggar.
    </p>
    </div>

    <div class="redovisning">
     <h1><a href="{{ path("kmom06") }}">kmom06</a></h1>
    <p>
    
    phpmetrics är ett användbart verktyg för att få en djupare förståelse för kodens kvalitet och struktur
    genom att tillhandahålla olika metriker och analyser.
    Några av de mest värdefulla bitarna kan vara metriker som cyclomatic complexity,
    kodtäckning och maintainability index, eftersom de ger insikter om kodens komplexitet,
    testningsgrad och underhållbarhet. Vid min första bedömning fick jag betyget 9.91.
    <br>

    Integreringen med Scrutinizer kan vara en fördel eftersom det ger möjlighet att integrera flera kvalitetskontroller och analyser
    på en plattform. Detta gör det enklare att få en samlad bild av kodkvaliteten och
    möjliggör att åtgärda problem på ett effektivt sätt.
    <br>

    Första känslan av verktyget och dess badges kan vara positiv om man ser att kodtäckning och kodkvalitet är höga.
    Det ger en känsla av att koden är väl underhållen och av hög kvalitet.
    Men det är viktigt att komma ihåg att badges inte är en fullständig indikator på kodkvalitet. 
    De kan ge en överblick, men för att bedöma kodkvaliteten på ett mer ingående sätt krävs en mer djupgående analys.
    jag fick 9.91 för kodkvalitet och 21% för kodtäckning.
    <br>

    Min syn på kodkvalitet innefattar flera aspekter, inklusive läsbarhet, underhållbarhet, testbarhet och prestanda.
    En hög kodkvalitet innebär att koden är lätt att förstå, ändra och testa samt att den fungerar effektivt och pålitligt.
    <br>

    Jag tror att badges kan vara en användbar indikator på kodkvalitet i viss utsträckning,
    men de bör kompletteras med andra metoder och verktyg för att få en mer komplett bild.
    Att ha en hög kodtäckning och ett högt betyg från verktyg som Scrutinizer kan vara ett tecken på god kodkvalitet,
    men det är inte alltid en garanti.
    Det är viktigt att använda flera olika metoder för att bedöma kodkvaliteten på ett heltäckande sätt.
    <br>

    Under kursens gång fick jag en djupare förståelse för vad clean code innebär och bekantade mig med de sex
    C:na (Codestyle, Coverage, Complexity, Cohesion, Coupling, CRAP).
    Jag lärde mig även om olika mätvärden och hur man kan tänka för att uppnå en clean code.
    Integreringen av Scrutinizer och phpmetrics var en lärorik erfarenhet
    som gav mig verktyg för att bedöma och förbättra min kodkvalitet.
    </p>
    </div>

    <div class="redovisning">
     <h1><a href="{{ path("kmom10") }}">kmom10</a></h1>
    <p>
                Jag har valt att göra ett BlackJack-spel av två anledningar.
                För det första började jag med det i kursmoment 3,
                så jag har redan en kodbas att utgå ifrån och en klar bild i huvudet av hur spelet ska vara.
                För det andra tycker jag om att utveckla spel eftersom det innebär mycket logikprogrammering, vilket jag tycker om.
            <br>
            <h2>Krav 1-3</h2>
            Jag började med att spela BlackJack online för att förstå spelet och spelupplevelsen.
            Därefter skrev jag klasser som jag skulle behöva, såsom Bank, Player, Game, DeckOfCards och Counter.
            Jag testade varje klass och metod stegvis, såsom split, bet,
            kortberäkning som hjälper spelaren att satsa och bedöma svårigheten för datorn.
            <br>
            Jag implementerade en räkningsteknik som visar spelaren om hen ska satsa högt eller lågt baserat på de dragna korten.
            Detta görs genom att räkna korten med plus eller minus och sedan dela det med antalet kvarvarande kort.
            Dessutom skapade jag en visualiserad statistiktabell som visar vilka kort som har dragits och hur många gånger.
            <br>
            För att förbättra spelet, lade jag till en funktion som visar sannolikheten för att spelaren ska bli tjock om ett nytt kort dras.
            Spelaren kan också välja datorns svårighetsgrad,
            med tre olika nivåer: easy, basic och advanced.
            På easy-nivån slutar datorn dra kort vid 20,
            på basic vid 17 och på advanced räknar datorn kort och bedömer sannolikheten att bli tjock.
            <br>
            Jag implementerade även en funktion som tillåter spelaren att splitta handen om hen får två kort med samma värde,
            och handen kan endast splittas en gång.
            <br>
            Att designa spelet var en utmaning eftersom jag ville ge användaren en känsla av verklighet så mycket som möjligt.
            Jag valde färger som grönt och mörkrött och gjorde spelet lätt att spela.
            Med hjälp av JavaScript kunde spelaren klicka på kort för att aktivera handen eller välja svårighetsnivå.

            <br>
            <h3>Testing</h3>
            Jag började med att skriva tester för mina klasser. Detta var inte lätt eftersom många klasser använder andra klasser,
            så jag fick mocka metoder och klasser för att kunna testa alla metoder.
            Jag lyckades få 99,61% kodtäckning för alla klasser som används i projektet (BlackJack-spelet) förutom kontroller.
            Detta syns tydligt om ni kollar på täckningsrapporten för BlackJack-projektet.
            <br>
            Jag genererade dokumentation med PHPDoc och metriker med PHPMetrics.
            <h2>Krav 4 (JSON API)</h2>
            Att skriva API-koden var inte så svårt jämfört med själva spelet eftersom jag har arbetat med API
            under kursen. Jag skapade 6 API-rutter: 3 POST och 3 GET, som gör det möjligt att spela spelet.
            En ruta för att starta ett spel, en för att spelaren kan dra kort, en för bankens tur,
            en som visar vinnaren och en som visar spelets status. Jag hanterade POST-förfrågningar med hjälp av JavaScript,
            där jag använde onclick-metoden för att välja och anropa rätt metod.
            <br>
            <h2>Utmaningar och Reflektioner</h2>
            Att genomföra hela projektet var både svårt och kul.
            Jag tycker om att programmera logik och lösa problem, men det var svårt eftersom jag inte är duktig på att spela BlackJack.
            Jag hade problem med att hitta ett sätt att räkna kort (som är en otillåten aktivitet).
            Jag läste mycket om hur man kan räkna kort och började sedan skriva Counter-klasser som räknar kort och hjälper spelaren att räkna kort.
            <br>
            En annan utmaning var split-metoden. I början visste jag inte hur jag skulle göra så att bara kort med samma värde kunde splittas.
            Jag skapade en metod som kontrollerar om spelaren uppfyller kraven för att splitta,
            såsom antal tokens och att korten har samma värde, samt att splittade händer inte kan splittas igen.
            <br>
            Jag tycker att projektet var lite svårt men roligt att implementera och det passar bra för kursen.
            Kursen var mycket lärorik, vi lärde oss mycket om PHP-klasser, att arbeta i Symfony-miljö och att använda verktyg som Metrics,
            Scrutinizer, PHPStan och PHPMD. Lärarna var mycket hjälpsamma och jag fick snabba svar på mina frågor på Discord.
            Jag är mycket nöjd med kursen och skulle gärna rekommendera den till vänner. Jag ger kursen 10 av 10 i betyg.
                        </p>
    </div>
  
    
</div>
{% endblock %}